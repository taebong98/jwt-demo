# 프로젝트 개요
Java 기반 백엔드 REST API 구축 과제

# 개인적인 도전 과제

# Swagger 주소 및 요구사항 구현 여부
## (1) 회원가입 - 사용자가 삼쩜삼에 가입해야 합니다.
- [x] 엔드포인트: POST `/szs/signup`
- [x] 필수 파라미터에 대한 유효성 검증 및 데이터베이스 제약조건 설정
  - 정규표현식을 통해 주민등록번호 형식 검증
  - userId, password, name, regNo 컬럼에 대해 데이터베이스 제약조건 설정
- [x] 정해진 유저만 회원가입이 가능하다.
- [x] 패스워드와 주민등록번호는 암호화 된 상태로 저장한다.

### 구현 방법
#### 1-1. 정해진 유저만 회원가입이 가능해야 한다.
- Map 자료구조를 통해 정해진 사용자 목록을 관리(`com.taebong.szs.domain.vo.AllowedUsers`)
  - `AllowedUsers` 클래스를 Bean으로 등록한뒤 UserService에서 DI 받아 사용자 목록을 조회 
  - 기존 List를 사용하는 코드를 Map 자료 구조를 사용하도록 변경 
    - (commit: `a3af24475b0604e034b81682ff55b2b127e1602b`)
  - 서비스 규모가 커지거나 요구사항이 변경되면서, **회원가입 가능 유저의 수가 늘어날 가능성을 고려**
  - Map 자료구조를 사용하면 상수시간(`O(1)`)에 데이터를 검색할 수 있기 때문에, 회원가입 가능 유저의 수가 기하급수적으로 늘더라도 병목이 발생할 가능성이 적다고 판단.

#### 1-2 민감정보는 암호화 된 상태로 저장해야 한다.
- Spring Security에서 제공하는 암호화 기능을 사용
  - `BCryptPasswordEncoder.encode()` 메서드를 활용하여 비밀번호와 주민등록번호 암호화 진행
    - 별도의 설정이나 구현 없이 안전한 암호화 기능 사용 가능
    - 솔팅기술을 사용하여 브루트포스 공격 및 레인보우 테이블 공격에 대응 가능

### 검증 결과
**단위테스트, API 호출을 통해 검증**
- [x] `userId`, `password`, `name`, `regNo` 데이터 없이 회원가입 불가능
- [x] `password`와 `regNo`는 암호화하여 데이터베이스에 저장
- [x] 정해진 사용자만 회원가입 가능
  - [x] 이름과 주민등록번호가 일치하는 경우 회원 가입 가능
  - [x] 이름과 주민등록번호가 일치하지 않으면 `ForbiddenException` 발생
  - [x] 회원가입 요청을 보내는 사용자가 정해진 사용자 목록에 존재하지 않으면 `ForbiddenException` 발생

## (2) 가입한 회원을 로그인 하는 API를 작성해주세요.
- [x] 엔드포인트: POST `/szs/login`
- [x] body로 아이디와 비밀번호를 받는다.
- JWT + Spring Security
  - [x] 데이터베이스에 사용자 아이디가 없다면 커스텀예외 발생
  - [x] 로그인 비밀번호와 데이터베이스의 비밀번호가 다르다면 커스텀예외 발생
  - [x] 로그인 파라미터와 저장하고 있는 사용자 정보가 같다면 토큰 발급

### 구현방법
#### 2-1. 사용자 정보를 데이터베이스에서 조회한다.
- 클라이언드로 부터 받은 'userId'를 이용하여 데이터베이스에서 사용자를 검색한다.
  - SpringDataJpa의 findByUserId 사용
  - 해당 사용자가 없는 경우 NullPointerException을 대비하여 Optional 사용
  
#### 2-2. 로그인 시 입력한 패스워드와 데이터베이스에 저장되어 있는 패스워드를 검증한다.
- 암호화 되어 저장돼 있는 패스워드와 평문으로 입력받은 패스워드 일치여부를 검증
  - PasswordEncoder의 match() 메서드 사용
- 만약 비밀번호가 일치하지 않다면 커스텀 예외인 LoginException을 발생시킨다.

#### 2-3. 사용자에게 토큰을 발행해준다.
- id와 password가 일치한다면 JWT 토큰 발행
- JWT 발급을 담당하는 별도의 클래스(`JwtTokenProvider`)를 생성한뒤 DI 받아 사용
  - Key 객체 발급, Claims, expire 등의 관심사는 UserService의 관심사와 별도로 관리되어야 한다고 판단
  - 또한 사용자 인증, 권한정보 조회 등 미래에 생겨날 가능성이 있는 요구사항을 관리하기도 용이할 것이라고 생각함 
- 평문으로 입력된 secretKey를 Base64로 인코딩하여 Key객체 생성
  - yml에 저장된 secretKey 노출을 방지하기 위해 Jsypt 등 암호화 라이브러리를 사용 필요(이 부분은 생략했습니다 😃)

### 검증 결과
**단위테스트, API 호출을 통해 검증**
- [x] 요청 파라메터로 받은 userId로 사용자 정보를 조회한다.
- [x] 요청 파라메터로 받은 password와 데이터베이스에 저장되어 있는 password가 일치하면 JWT 토큰을 발행한다.

## (3) 가입한 회원 정보를 가져오는 API를 작성해주세요.
- [x] 엔드포인트: GET `/szs/me`
- [x] header 형식: "Authorization: Bearer {JWT Token}"
- [x] 인증 토큰을 이용하여 자기 정보만 볼 수 있어야 한다.
  - [x] 인증토큰은 헤더로 전달한다. 
  - [x] 인증 토큰 Claims에서 자기 정보를 조회한 뒤 클라이언트로 리턴
  - [x] 토큰 파싱하면서 적절한 예외처리 필요
  - [x] 암호화 방식 변경(복호화 가능하도록)

### 구현방법
#### 3-1. 복호화 암호화 알고리즘 변경
  - JWT 토큰으로부터 사용자 정보를 조회하기 위해 암호화 되어있는 정보를 복호화 할 필요가 있었음
  - 이를 위해 기존에 사용중이던 `PasswordEncoder`에서 `Encryptors`로 변경

#### 3-2. 사용자 데이터 조회 방법
  - JWT에 모든 정보를 넣을것인지, userId만 관리하고 요청마다 데이터베이스에서 정보를 조회해올 것인지에 대해 고민
  - **JWT에 모든 정보를 넣는 경우 단점**
    - 네트워크 사용량 증가
    - JWT에 민감정보를 저장하고 있기 때문에 보안 이슈 발생 가능
  - **userId를 통해 데이터베이스에서 사용자 정보를 조회하는 경우 단점**
    - 데이터베이스와 통신 과정에서 발생하는 비용
  - **결과**
    - "인증 토큰 이용하여"라는 요구사항에 따라 전자의 방식 선택
    - 민감정보를 암호화시킨 상태로 JWT에 저장
    - "userId, name, password, regNo" 만 저장하기 때문에 네트워크 전송량에 큰 영향이 없다고 판단

#### 3-3. 암호화 관심사 분리
- 암호화, 복호화, 비교 로직을 담당하는 `CryptUtils` 클래스 생성
- UserServicd에서만 CryptUtils을 의존하기 때문에 현재와 같이 암호화 알고리즘이 변경되어도 유지보수, 변경, 확장에 용이

### 검증결과
**단위테스트, API 호출을 통해 검증**
- [x] Header에 JWT 토큰을 보내면 해당 토큰을 파싱하여 userId, name, password, regNo를 클라이언트로 리턴