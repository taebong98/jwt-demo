# 프로젝트 개요
Java 기반 백엔드 REST API 구축 과제

# 개인적인 도전 과제

# Swagger 주소 및 요구사항 구현 여부
## (1) 회원가입 - 사용자가 삼쩜삼에 가입해야 합니다.
- [x] 엔드포인트: POST `/szs/signup`
- [x] 필수 파라미터에 대한 유효성 검증 및 데이터베이스 제약조건 설정
  - 정규표현식을 통해 주민등록번호 형식 검증
  - userId, password, name, regNo 컬럼에 대해 데이터베이스 제약조건 설정
- [x] 정해진 유저만 회원가입이 가능하다.
- [x] 패스워드와 주민등록번호는 암호화 된 상태로 저장한다.

### 구현 방법
#### 1-1. 정해진 유저만 회원가입이 가능해야 한다.
- Map 자료구조를 통해 정해진 사용자 목록을 관리(`com.taebong.szs.domain.vo.AllowedUsers`)
  - `AllowedUsers` 클래스를 Bean으로 등록한뒤 UserService에서 DI 받아 사용자 목록을 조회 
  - 기존 List를 사용하는 코드를 Map 자료 구조를 사용하도록 변경 
    - (commit: `a3af24475b0604e034b81682ff55b2b127e1602b`)
  - 서비스 규모가 커지거나 요구사항이 변경되면서, **회원가입 가능 유저의 수가 늘어날 가능성을 고려**
  - Map 자료구조를 사용하면 상수시간(`O(1)`)에 데이터를 검색할 수 있기 때문에, 회원가입 가능 유저의 수가 기하급수적으로 늘더라도 병목이 발생할 가능성이 적다고 판단.

#### 1-2 민감정보는 암호화 된 상태로 저장해야 한다.
- Spring Security에서 제공하는 암호화 기능을 사용
  - `BCryptPasswordEncoder.encode()` 메서드를 활용하여 비밀번호와 주민등록번호 암호화 진행
    - 별도의 설정이나 구현 없이 안전한 암호화 기능 사용 가능
    - 솔팅기술을 사용하여 브루트포스 공격 및 레인보우 테이블 공격에 대응 가능

### 검증 결과
**단위테스트, API 호출을 통해 검증**
- [x] `userId`, `password`, `name`, `regNo` 데이터 없이 회원가입 불가능
- [x] `password`와 `regNo`는 암호화하여 데이터베이스에 저장
- [x] 정해진 사용자만 회원가입 가능
  - [x] 이름과 주민등록번호가 일치하는 경우 회원 가입 가능
  - [x] 이름과 주민등록번호가 일치하지 않으면 `ForbiddenException` 발생
  - [x] 회원가입 요청을 보내는 사용자가 정해진 사용자 목록에 존재하지 않으면 `ForbiddenException` 발생

## (2) 로그인 - 가입한 회원을 로그인시킨다.
- [x] 엔드포인트: POST `/szs/login`
- [x] body로 아이디와 비밀번호를 받는다.
- JWT + Spring Security
  - [x] 데이터베이스에 사용자 아이디가 없다면 커스텀예외 발생
  - [x] 로그인 비밀번호와 데이터베이스의 비밀번호가 다르다면 커스텀예외 발생
  - [x] 로그인 파라미터와 저장하고 있는 사용자 정보가 같다면 토큰 발급

### 구현방법
#### 2-1. 사용자 정보를 데이터베이스에서 조회한다.
- 클라이언드로 부터 받은 'userId'를 이용하여 데이터베이스에서 사용자를 검색한다.
  - SpringDataJpa의 findByUserId 사용
  - 해당 사용자가 없는 경우 NullPointerException을 대비하여 Optional 사용
  
#### 2-2. 로그인 시 입력한 패스워드와 데이터베이스에 저장되어 있는 패스워드를 검증한다.
- 암호화 되어 저장돼 있는 패스워드와 평문으로 입력받은 패스워드 일치여부를 검증
  - PasswordEncoder의 match() 메서드 사용
- 만약 비밀번호가 일치하지 않다면 커스텀 예외인 LoginException을 발생시킨다.

#### 2-3. 사용자에게 토큰을 발행해준다.
- id와 password가 일치한다면 JWT 토큰 발행
- JWT 발급을 담당하는 별도의 클래스(`JwtTokenProvider`)를 생성한뒤 DI 받아 사용
  - Key 객체 발급, Claims, expire 등의 관심사는 UserService의 관심사와 별도로 관리되어야 한다고 판단
  - 또한 사용자 인증, 권한정보 조회 등 미래에 생겨날 가능성이 있는 요구사항을 관리하기도 용이할 것이라고 생각함 
- 평문으로 입력된 secretKey를 Base64로 인코딩하여 Key객체 생성
  - yml에 저장된 secretKey 노출을 방지하기 위해 Jsypt 등 암호화 라이브러리를 사용 필요(이 부분은 생략했습니다 😃)